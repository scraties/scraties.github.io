{"posts":[{"title":"两种结构型设计模式","content":"本文介绍了两种结构型设计模式——适配器模式和装饰器模式。 <!--more--> 适配器模式 适配器模式就是用另一个类作为“适配器”，将原来的类的操作转换成用户需要的形式。用户只需要和这个“适配器”打交道，而不需要和原来的类打交道，“适配器”通过委托（也就是说，原来的类作为“适配器”的属性）调用原来的类的方法完成任务。 对于： 增加“适配器”： 现在用户跟LegacyRectangle就被Rectangle**”适配“**了，用户只需要使用Rectangle里的操作即可。 装饰器模式 我们知道如果想要给一个ADT增加特性的话，我们可以写一个子类，重写父类中的方法。这样的确可以增加特性，但是如果我们想要将这些特性组合起来，我们就会遇到问题。 因为这些子类相互之间没有关系，我们不得不为这些子类再增加子类来实现特性的组合。随着特性的增多，可能我们还得实现子类的子类的子类，以及子类的子类的子类的子类，这就会产生组合爆炸的问题。 装饰器模式正是用来解决这个问题的。它将不同的特性通过层层嵌套的方法组合起来，而不需要额外的代码。 对于： 我们实现一个通用的装饰器抽象类： 然后实现一个用于加装特性的装饰器具体类： 当我们想使用加装了特性的Stack的时候，我们可以： 装饰器模式最大的特点是将Stack作为构造方法的参数，赋给内部的属性，对这个属性进行复用。这个Stack不仅可以是通用的ArrayStack，它可以是任何Stack，也就可以是加装了特性后的Stack，例如UndoStack，从而实现了特性组合的方法——层层嵌套。 如果我们再定义两个装饰器具体类： 我们就可以这样将它们组合起来： 可以看到我们使用层层嵌套实现了特性的组合，不需要多余的代码，没有产生组合爆炸。 ","link":"https://www.scraty.top/post/TwoStructualPatterns/"},{"title":"工厂方法设计模式","content":"本文是对工厂方法设计模式的一个介绍。 <!--more--> 工厂方法模式 工厂方法模式顾名思义就是创建一个“工厂”方法来隔离类的使用与具体的类。 对于 我们一般使用的时候会这样： 创建一个工厂方法： 然后我们可以这样： 可以看到，我们将实例化这个过程封装到了工厂方法里，这就将实例化类的责任抛给了工厂方法，用户只需要提供对于“产品”的描述（甚至有时候不需要描述，如果用户不在意的话），就可以获得“产品”。 在这个例子里，用户只关心动物脚的个数，工厂方法满足了用户这个需要，让用户只需要提供脚的个数就可以帮助用户做出选择，返回默认的动物。如果想要更换这个动物的话，只需要修改工厂方法即可，不需要修改每个用到实例化的地方。 可以将工厂方法放在单独的工厂类中，例如： 也可以将工厂方法用static修饰，直接放到“产品”接口里，例如： ","link":"https://www.scraty.top/post/FactoryMethodPattern/"},{"title":"计算机系统大作业-C/C++语言的秘密","content":"计算机系统大作业，应课程要求发在博客上。 <!--more--> ","link":"https://www.scraty.top/post/CSAPP/"},{"title":"泛型的类型擦除","content":"本文主要介绍泛型在虚拟机中的实现——使用类型擦除的方法。 <!--more--> 类型擦除 Java虚拟机中没有泛型类型对象，所有的类都属于普通类。因此Java编译器使用一个普通的类来实现泛型，这个普通类称为相应泛型的原始类型。例如对于如下泛型程序： 它的原始类型如下： 可以看到，&lt;T&gt;没有了，类型变量T被擦除了，并替换为了Object。 这里的T没有任何限定，因此替换为Object。如果这里的T有限定的话，会替换为其限定类型。 类型变量的限定使用如下形式： 这里的BoundingType就是限定类型。上面这种写法将T限定为BoundingType的子类型。 T和BoundingType可以是类，也可以是接口。因为Java中可以同时实现多个接口，所以这里的限定类型也可以有多个。多个限定类型使用如下形式： 但是其中最多有一个可以是类，其他的只能是接口。 有多个限定类型时，会使用第一个限定类型进行类型擦除。 例如对于如下例子： 它的原始类型如下： 编译器的作用 尽管在虚拟机中，泛型类型实际上是一个普通的类，但是编译器不会让你像使用一个普通的类一样使用它。它会对你的使用加以限制，并自动地帮我们做一些事情，让泛型看起来像一个“泛型”。 这主要有以下两点： 调用一个泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换。 编译器使用桥方法来保证泛型子类的多态性。 关于第一点，对于下面这个语句序列： 我们知道buddies.getFirst()类型擦除之后返回类型是Object，跟buddy的类型是不一样的。这时候，编译器会自动插入到Employee的强制类型转换。 对buddies.getFirst()方法的调用实际上被编译器转换为两条虚拟机指令： 对原始方法Pair.getFirst的调用。 将返回的Object类型强制转换为Employee类型。 关于第二点，对于下面这个类： 这里它对于setSecond方法的重写应该是有效的，但是它类型擦除之后会变成： Pair中setSecond方法参数是Object类型的，因此上面实际上是在重载方法，而不是在重写，DateInterval中还会有一个从Pair继承的方法： 两个方法是不同的，但是它们不应该是不同的。 这时候，编译器会自动生成一个桥方法： 可以看到，编译器用我们编写的方法重写了原来的方法，从而使得我们看上去自己“重写了”原来的方法。 参考资料 书籍 Java核心技术 卷Ⅰ 基础知识（原书第11版） 第8章 ","link":"https://www.scraty.top/post/TypeErasure/"},{"title":"异常类的创建与序列化","content":"本文首先介绍了Java异常类的层次结构，然后描述了如何创建异常类，最后介绍了在创建异常类的过程中会遇到的序列化问题。 <!--more--> 我们在进行Java编程时经常需要抛出和捕获各种异常，用来处理程序执行过程中可能出现的各种错误。但是我们可能会遇到任何标准异常类都无法描述清楚的情况，这时就需要创建自己的异常类。 Java异常类的层次结构 Java中所有异常类都派生于Throwable类。但是在Throwable的下一层，有两个分支，分别是： Error：描述了各种我们无能为力的系统内部错误 Exception：又分为两个分支，RuntimeException类和其他异常 （注意：IOException只是其他异常的一种） 区分RuntimeException和其他异常的一般规则是： 由于编程错误导致的异常属于RuntimeException 如果程序本身没有问题，那么是其他异常 Error我们完全无法处理，RuntimeException我们完全可以避免。所以Java编译器只会检查你是否为其他异常提供了异常处理器，而不会检查Error和RuntimeException。 因此Error与RuntimeException被称为**非检查型(unchecked)异常，其他异常被称为检查型(checked)**异常。 创建异常类 从上面的描述可以知道，我们需要创建一个检查型异常，即Exception及其子类（除去RuntimeException）的派生。 因此我们创建一个Exception的子类作为示范。 根据书上描述的习惯做法，我们定义两个构造器，一个是默认的构造器，一个是包含详细信息的构造器，代码如下（注释省略）： 但是我们会发现上述代码在eclipse里运行的时候会有Warning eclipse自动增加了一行代码后解决了问题： 那么为什么会出现这个Warning，加了这行代码又为什么可以解决问题呢？ 序列化与Serializable接口 我们找到Throwable的声明： 发现Throwable实现了接口Serializable 而我们创建的IntervalConflictException是Throwable的派生，根据继承规则，自动实现（implements）了Serializable，而不需要显式的声明。 那么Serializable接口里到底有什么呢，答案是Serializable接口里什么都没有，是一个空接口。 空接口只是一个标识，只是为了将一些类区分出来。 就好比上课举手。任何听课的人都可以举手，举手只是为了告诉老师，举手的人有话要说。 同样地，Serializable只是告诉Java可以对这个对象进行序列化 Serializable是Java序列化的标识，实现了它就意味着它的对象可以被序列化。 序列化是一种跨平台储存和网络传输对象的机制。它将对象以特定的规则转化为字节数组，然后通过IO的方式进行跨平台存储和网络传输。反序列化是序列化的逆过程，将字节数组转化回对象。 简单来说，序列化是一种为了方便大家之间传递程序而产生的机制，它使得软件提供商可以将软件分发给你。如果你是单机玩家，那么序列化对你没什么意义。 因此我们创建的IntervalConflictException的对象是可以序列化的，这个类应该满足序列化的要求。 serialVersionUID 序列化的要求之一就是要有serialVersionUID。 serialVersionUID是序列化的版本号，用来判断对象的版本有没有改变。 如果软件版本发生改变，你的软件可能会让你更新 serialVersionUID可以使用两种方式生成： 默认的1L。版本变化之后手动改为2L，3L，4L，以此类推；不一定要连续，跟之前的版本不一样就行，重点是手动更新 使用hash算法。通过包名，类名，继承关系，各种方法和属性等用哈希算法生成一个值，只要对代码进行了更改，计算出来的哈希值就会不一样。 如果不显式地声明一个serialVersionUID，就会使用hash算法自动生成一个serialVersionUID。 但是，自动生成的serialVersionUID对类的细节高度敏感。这会造成两个后果： 只要类修改了一点点，serialVersionUID就会发生变化 即使我们没有修改代码，但是这些细节仍然可能因为编译器的不同而发生变化，从而使serialVersionUID发生变化，这会导致反序列化时出现问题 （即出现InvalidClassException异常） 大多数时候我们不希望serialVersionUID对细节如此敏感，因此Java编译器会强烈建议我们显式地声明serialVersionUID，从而会弹出一开始的Warning。 参考资料 书籍 Java核心技术 卷Ⅰ 基础知识（原书第11版） 第7章 网站 关于Throwable 关于serialVersionUID 依旧关于serialVersionUID 关于Serializable接口 关于序列化 依旧关于序列化 关于eclipse报的Warning 关于继承 ","link":"https://www.scraty.top/post/MyExceptionAndSerialization/"},{"title":"ADT小结","content":"本文是对ADT相关知识点的总结。 <!--more--> ADT是什么 ADT是抽象数据型(Abstract Data Type)的简称。实际上ADT就是类(class)，只是从不同的视角来看。 ADT认为类是一种数据类型。不过跟传统的数据类型不同的是，ADT不关注数据的具体表示，而是强调“作用于数据上的操作”，认为这些操作完全定义了数据类型（即ADT）。 ADT分为两类： mutable类型：提供了可以改变内部值的操作。 immutable类型：任何操作不改变内部值，而是构造新的对象。 ADT的四种操作 ADT的所有操作可以分为四种： Creators：构造器，通过其他类型构造出一个本类型的ADT对象。可以实现为构造函数或者静态函数。实现为静态函数时经常被称为工厂方法。 Producers：生产器，使用ADT对象生成其他的ADT对象。 Observers：观察器，观察ADT对象的属性。 Mutators：变值器，改变ADT对象的属性。通常返回void，这时它一定改变了对象的某些内部状态，也可能返回非空类型。immutable类型的ADT一般不能有Mutators 这四种操作形式上的区别如下： Creators：t* -&gt; T Producers：T+, t* -&gt; T Observers：T+, t* -&gt; t Mutators：T+, t* -&gt;void | t | T 其中T表示ADT自己，t表示其他类型，+表示出现一次或多次，*表示出现0次或多次，|表示或。 表示独立性、不变量与表示泄露 表示独立性(Representation Independence)就是说客户端(client)在使用ADT的时候无需考虑其内部如何实现，ADT方法的spec（规约）规定了client和ADT之间的契约。也就是说，spec是一道“墙”，墙内外不能相互影响。client不能改变ADT对象内部的值，ADT内部表示的变化不能影响spec和client（即使ADT更换了实现方法，也还是要满足spec）。 不变量(Invariants)是为了保持程序的正确性而存在的，它是一组总是正确的条件。不变量是由ADT负责的，跟client无关。应该为ADT规定一个不变量，然后在每个方法中检查这个不变量。 表示泄露(rep exposure)就是说ADT外部的代码（指client）可以直接改变ADT内部的属性。这不仅影响了不变性，也影响了表示独立性。 如何避免表示泄露： 尽量使用immutable的属性（最好的方法） 尽量使用private和final修饰属性 mutable的属性在传入ADT（例如构造方法中）和传出ADT（例如Observer中）时要进行defensive copy（防御性拷贝） AF和RI 每个ADT都有两个空间，一个叫表示空间R，一个叫抽象空间A。抽象空间是client看到的空间，表示空间是ADT开发者看到的空间。 AF（抽象函数，Abstraction Function）是R到A的映射，即如何将R中的每一个值解释为A中的每一个值，形式地说，就是AF : R -&gt; A。 RI（表示不变性，Rep Invariant）是对表示空间的约束，描述了什么样的表示是“合法的”。可以认为RI是所有表示值的一个自己，包含所有合法的表示值；也可以认为RI是一个条件，描述了什么是“合法”的表示值。 AF和RI跟内部表示有关，当你选择了一种表示抽象值的方式的时候，你就需要指定某个子集是“合法的”（这就是RI），然后你需要为该子集中的每一个值做出“解释”——即如何映射到抽象空间中的值（这就是AF）。 ","link":"https://www.scraty.top/post/ADT/"}]}